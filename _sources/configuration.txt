.. FAT Arts CombinatÃ²ries documentation master file, created by
   sphinx-quickstart on Tue May 31 12:39:26 2011.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Configuration
======================================================================================

There are several aspects that must be defined in order to get the Semantic Web (SW) working with a new Ontology. This configuration guide is organized step-by-step.

Step 0: Virtuoso
---------------------------

Some Virtuoso initial configuration is necessary. Access to Virtuoso Conductor console (default should be: http://localhost:8890/conductor/ with both user and password "dba"). Click "Interactive SQL" on the right, and run the next sql script:

::

    -- Base script which creates necessary data structure for managing users, rights and uploaded media and objects
    -- Suitable (only?) for Openlink Virtuoso sql implementation
    
    --DROP TABLE db.dba._media;
    CREATE TABLE db.dba._media (
	    SID INT IDENTITY,
    	mediaId VARCHAR(60),
	    path VARCHAR(500),
	    moment TIMESTAMP
    )

    --DROP TABLE db.dba._thumbnail;
    CREATE TABLE db.dba._thumbnail (
	    SID INT IDENTITY,
	    objectId VARCHAR(60),
	    path VARCHAR(500),
	    moment TIMESTAMP
    )

    --DROP TABLE db.dba._right;
    CREATE TABLE db.dba._right (
	    SID INT IDENTITY,
	    objectId VARCHAR(60),
	    rightLevel INT
    )

    --DROP TABLE db.dba._identifier_counter;
    CREATE TABLE db.dba._identifier_counter (
	    identifier VARCHAR(150),
	    counter INT
    )

    --DROP TABLE db.dba.autodata_table;
    CREATE TABLE db.dba.autodata_table (
	    keyName VARCHAR(100),
	    keyValue VARCHAR(100),
	    name VARCHAR(100),
	    defaultValue VARCHAR(100)
    )

    GRANT EXECUTE ON DB.DBA.SPARQL_DELETE_DICT_CONTENT TO "SPARQL";
    GRANT ALL PRIVILEGES TO "SPARQL";

(Note that you can uncomment "drops" to reset all tables)

Next, click "RDF" tab, and click "Namespaces", you must add here all linked ontology namespaces not included in the list. Keep in mind that those namespaces are eligible for use, and that all ontologies specified in "ONTOLOGY_NAMESPACES" in Configuration (see Step 1) must appear in this list.

Step 1: Main properties
----------------------------

Once installed (see Installation) and Virtuoso is configured, the first thing we have to do is to configure the 'config.json' file, you may place them on your current directory (when running on Tomcat, it is: $TOMCAT_HOME/webapps/ROOT/). Here's a sample with some explanations:

::

    {	
        "__comment_0":"Mixed config",

	    "THUMBNAIL_WIDTH":250,
	    "THUMBNAIL_HEIGHT":180,
	    "VIDEO_FILE_EXTENSIONS":["dv", "mpg", "avi"],
	    "LANGUAGE_LIST":["ca", "en", "es", "fr", "it", "de"],							
	    "USER_LEVEL":["*", "Member", "Manager Reviewer", "Site Administrator"],	    
	
	    "__comment_1":"Services base URLs and connection strings",

	    "RDFDB_URL":"jdbc:virtuoso://localhost:1111",
	    "RDFDB_USER":"dba",
	    "RDFDB_PASS":"dba",
	    "REST_URL":"http://stress.upc.es:8080/ArtsCombinatoriesRest/",
	    "SOLR_URL":"http://localhost:8080/solr/",
	    "VIDEO_SERVICES_URL":"http://tapies.aur.i2cat.net:8080/TapiesWebServices/rest/",
	
        "__comment_2":"Ontology namespaces (After any change, all existing triples must be fixed)",

	    "RESOURCE_URI_NS":"http://localhost:8080/ArtsCombinatoriesRest/resource/",		
	    "RESOURCE_PREFIX":"ac_res",
	    "ONTOLOGY_NAMESPACES":[
		    "http://localhost:8080/rest/ontology/my#", "my",
		    "http://www.w3.org/1999/02/22-rdf-syntax-ns#", "rdf",
		    "http://www.w3.org/2000/01/rdf-schema#", "rdfs",
		    "http://dublincore.org/2010/10/11/dcterms.rdf#", "dcterms"
	    ],
	
	    "__comment_3":"File system paths",

	    "CONFIGURATIONS_PATH":"/home/jordi.roig.prieto/workspace/ArtsCombinatoriesRest/json/",
	    "SOLR_PATH":"/home/jordi.roig.prieto/solr/",
	    "MEDIA_PATH":"./ac_media/",
	    "ONTOLOGY_PATH":"./OntologiaArtsCombinatories.owl"
    }

ONTOLOGY_NAMESPACES stablishes a prefix for each ontology/schema namespace, this prefix must also appear on namespaces list in Virtuoso (see Step 0). The first specified ontology must be the one specially created for this project (myOntology in the example), other specified ontologies/schemas must be the ones included on the first one. Generally, RDF and RDFS schemas should be always included.

Step 2: Reset
-----------------------------

Calling reset service, ALL data and media will be removed. Also last Ontology file (located in ONTOLOGY_PATH) will be loaded. 

::

    Service path: http://{host:port}/{appname}/reset?option=ontology&confirm=CURRENT_DATE
    HTTP Method: GET
    Returns: "success" or "error"

Set "option=ontology" if you do not want a total reset, but only an Ontology reload.

Otherwise, for safety, "confirm" must be filled with current server date and time formated as "dd/mm/yy hh:mm"

**Examples**

::

    http://internetdomain.org/rest-path/reset?option=ontology               // ontology reload

::

    http://internetdomain.org/rest-path/reset?confirm=11/11/2011 23:11      // data reset and ontology upload



Step 3: Legal script
-----------------------------

AC provides capabilities for assigning legal rights to media objects. The right assignation is an user assisted process that can be scripted and fully customized. (If you have no intention to apply this feature you may skip this step).

There is a self-explanatory sample named 'legal.json' in json directory, 'legal' subfolder. 'legal.json' is the name of the script file that will assist the user, the main parts of the script are:

- Start Block: starting block of the script
- Blocks: list of blocks the process will run through.
- Block name: name of block user for referencing it from other blocks
- Block description: additional explanation of block aim
- Block data: data that will be requested to user (as a user form) and will be used to resolve the right assignation. This data is considered global, so it can be reused or reassigned in further blocks.
- Block rules: data evaluation using boolean expressions. It can result to a next block, indicaded by 'block' keyword, or to a color indicated by 'result' keyword. Color consequences is explained next.

There are four "trafic light" colors that can be assigned to any object as a result of the legal process. From less to more restrictive: "green", "yellow", "orange" and "red". Each of one corresponding to one accessing right level from 1 to 4. On every call to a service that provides media data, the accessing level must be specified. Service will fail if user accessing level is lower than object restriction level. Eg. User level = 1 , Object level = 2 --> Fail / User level = 2 , Object level = 2 --> OK.

Step 4: Data mapping
------------------------------

Data "mapping.json" (placed in json/mapping folder) is a must-have specification file that defines what ontology data must be indexed in Solr, and how this must be done. Data mapping is not a simple direct Owl to Solr mapping. It must be defined in a way that it later can be used for specific object domain searches (See Step 4), and provide additional information of the field nature to get Solr treating the data properly.

Let's say we have the Person class defined in our Ontology, and that we want to indexate several useful person data such as: name, biography, date of birth and birth place. Person indexation should be specified this way:

::

    {
	    "data":
	    [
            {
                "name":"Name",                  // Specifies the data identifier, in this case, the person Name
                "type":"string",                // 'string' type means that values of Name will be treated as a whole
                "path":["Person.fullName"]      // Path to Class data property, note that it's specified as (Class-name).(property)
            },

            {
                "name":"Biography",             
                "type":"text",                  // 'text' makes every word (space separated tokens) to be treated separately on search
                "path":["Person.Bio"]           
            },

            {
                "name":"BirthDate",             
                "type":"date.year",             // 'date.year' will extract the year part of date value (default date format expected is dd/mm/yyyy)
                "path":["Person.BirthDate"]           
            },

            {
                "name":"BirthPlace",             
                "type":"string",                
                "path":["Person.BirthPlace:Location.Name"]   // Note that as Birth Place is not a string but an external object, specified path chains both objects, from original, to target data (Name property of Location class). You can chain as many objects as you need.
            }
        ]
    }

Note that path is a json array, this makes it possible to specify various object indexation. Let's suppose that we want to indexate one more object: Locations (with property Name). Code should be modified as follows:

::

    "data":
        [
            {
                "name":"ObjectClass",           // This is not mandatory but totally recommended: As we have now more than one object type, 
                                                // specifying this data, will allow filtering searches by object class.
                "type":"string",
                "path":["*.class"]              // We want no specific class by '*' character instead of class name, 
                                                // and we use reserved word 'class' to get the indexated object class name. 
                                                // 'superclass', and 'id' are also a reserved words, with obvious results.
            },

            {
                "name":"Name",                                  
                "type":"string",                                
                "path":["Person.fullName", "Location.Name"]     // Path to Person and Location data property
            },

            /* rest of json ... */
        ]

To provide proper searches, we can specify additional clauses for each data:

- **category**: Solr searches will use 'facets' feature to categorize specified data values by grouping and counting equal matches.
- **multilingual**: Applicable to data introduced in various languages in RDF database. For instance, a person biography can be written in different languages. This prevents Solr search from returning the same data in different languages.
- **search**: This might sound obvious that all mapped data should be user for search, but it's not. There may be data that's interesting only as a search result but not for searching in its string value. Unless you specify this clause, mapped data is not considered for searching.
- **autocomplete**: Only if you specified the previous clause, you can activate autocomplete to get this data in the autocomplete search.

For example: 'Name' data (that is, person and location name) is interesting for search and autocomplete. But Person name is specified in single language, and Location name is specified in different languages. Also, we find interesting to categorize results by locations but not by persons. According to all this, previous json code should change as follows:

::

    "data":
        [
            {
                "name":"Person",                                  
                "type":"string",                                
                "path":["Person.fullName"],         
                "search":"yes",
                "autocomplete":"yes"
            },

            {
                "name":"Location",                                  
                "type":"string",                                
                "path":["Location.Name", "Person.BirthPlace:Location.Name"]
                "search":"yes",                     // Note that ALL clauses are unactive by default, 
                "autocomplete":"yes",               // so they must be always specified in case of need.
                "multilingual":"yes",
                "category":"yes"
            }

            /* rest of json ... */
        ]


Step 5: Object template
------------------------------------

Any object search will finally lead to individual object visualization. This makes it necessary to build templates for any Ontology object that should be visualizable. Object view is organized in sections, and each section contains a list of mapped data, in a similar way we used it in previous step.

Going back to Person object class example: name, birth date, and birth place should be placed at header. Biography can be placed at body, we can also use a 'knows' relation to get related Persons and we can place this at footer section. (Note that sections are totally customizable).

The resulting template file must be placed as "Person.json" (generally, (Class-name).json) in json/mapping directory. Code should look as follows:

::

    {
	    "className":"Person",
	
	    "sections":
	    [
		    {
			    "name":"header",                    // section name
			    "data":[
		
		        	{
					    "name":"Name",
					    "type":"text",
					    "path":["Person.fullName"]
				    },

                    {
					    "name":"BirthDate",
					    "type":"date",
					    "path":["Person.BirthDate"]
				    },

                    {
					    "name":"BirthPlace",
					    "type":"linkedObject",
					    "path":["Person.BirthPlace:Location.Name"]
				    }
			    ]
		    },
		
		    {
			    "name":"body",
			    "data":[
			
			     	{
			            "name":"Biography",
			            "type":"text",
			            "path":["Person.Bio"]
			        }
			    ]  
		    },

            {
			    "name":"footer",                    
			    "data":[
		
		        	{
					    "name":"Related",
					    "type":"search",
                        "path":["Person.id"],
                        "value":["RelatedPeople:"],
                        "categories":["Year", "Location"]
				    }
			    ]
		    }
	    ]
    }


Data 'type' clause has not much to do with 'type' defined in previous step. The following types are all the ones available for templates:

- **text**: suitable for most cases, it resolves path to literal value with no modification.
- **linkedObject**: it shows resolved data path along with the referenced object id, separated by '@'. For example: London@my_london_id, this allows to create an hyperlink to the referenced object, which would be http://internetdomain.org/rest-path/resource/my_london_id/...
- **objects**: resolves path to identifier value.
- **media**: resolves path to media url value.
- **date**: and its parts (**date.year**, **date.day**, **date.month**). Same effect as date defined at step 3.
- **search**: this is a quite sophisticated object that comprises Solr searching feature from indexed data filtered by the specified constraint defined as combination of value and path. In this example: the search will only result to persons ("Person.knows:") that know current person ("Person.id"). For detailed information about searches please see Visualization page.

Please note that **text**, **objects** and **media** have the same effect. They resolve the path the same way but resulting value type is supposed to be different. See Visualization Object Thumbnail section to further in **media** and **objects** types.



